# C++ Multi-Threading Tutorial 

This is a series of tutorials on c++ multithreading (Chinese) 

> 注意：目前本教學仍然在製作中，可能會遇到錯誤，請開 Issue 提出
>
> Windows 使用者請注意：目前本教學可能無法運行於 Windows 10 以前的版本

這是一個關於 C++ 多執行緒（Multi-Threading）的系列學習教學

## 背景要求 Required background

TBDs

## 配置要求 Required tools

TBD

## 簡介 Introductions

- [1.1 前言](#)
- [1.2 基本配置與設定](#)
- [1.3 Hello, Concurrent World !](#)

### 第一部分 使用多執行緒 Multi-Threading

#### 2 執行緒管理

- [2.1 任務函數](#)
- [2.2 啟動執行緒](#)
- [2.3 等待執行緒結束](#)
- [2.4 執行緒於背景執行](#)
- [2.5 傳遞引數](#)

#### 3 執行緒共享資料
- [3.1 不變量](#)
- [3.2 競爭條件](#)
- [3.3 互斥鎖](#)
- [3.4 執行緒安全的初始化](#)

#### 4 多執行緒的錯誤情況

- [4.1 ABA 問題與樂觀鎖](#)
- [4.2 阻塞問題](#)
- [4.3 破壞不變量](#)
- [4.4 資料競爭](#)
- [4.5 錯誤共享](#)
- [4.6 變數生命週期問題](#)
- [4.7 移動執行緒失敗](#)
- [4.8 死鎖](#)
- [4.9 競爭條件](#)

### 第二部分　平行化運算 Parallel Computing

#### 5 任務平行化

- [5.1 建立與結束任務](#)
- [5.2 計算圖](#)
- [5.3 衡量平行化的效率](#)
- [5.4 阿姆達爾定律](#)

#### 6 迴圈平行化

- [6.1 平行矩陣運算](#)
- [6.2 迴圈平行化的柵欄 (barrier)](#)
- [6.3 平行化求和 (Parallel sum)](#)
- [6.4 分組迭代 (Chunking)](#)

#### 7 排序演算法的平行化

- [7.1 冒泡排序](#)
- [7.2 奇偶換位](#)
- [7.3 希爾排序](#)
- [7.4 快速排序](#)
- [7.5 數基排序](#)

#### 8 搜尋演算法的平行化

- [8.1 未排序序列](#)
- [8.2 二分法搜尋](#)

#### 9 圖論演算法的平行化

- [9.1 深度優先](#)
- [9.2 最短路徑](#)
- [9.3 最小生成樹](#)

### 第三部分 並行化設計 Concurrent Programing

#### 10 並行與同步操作

- [10.1 等待事件](#)
- [10.2 一次性的等待事件](#)
- [10.3 有時限的等待](#)
- [10.4 操作同步的簡化設計](#)

#### 11 記憶體模型 (Memory Model)

- [11.1 記憶體模型的結構面與並行面](#)
- [11.2 原子操作 (atomic operation)](#)
- [11.3 同步操作與順序限制](#)

#### 12 鎖定式並行設計

- [12.1 並行設計](#)
- [12.2 鎖定式並行資料結構](#)
 
#### 13 無鎖定並行設計

- [13.1 無鎖定資料結構](#)
- [13.2 無鎖定設計範例](#)
- [13.3 無鎖定設計原則](#)

### Part 4 案例研討：金融市場模擬 Case Study : Simulation of Financial Markets 

#### 14 金融商品定價方法

- [14.1 期望值與模擬](#)
- [14.2 折現因子與利息](#)
- [14.3 定價理論與二項樹](#)

#### 15 蒙地卡羅模擬

- [15.1 蒙地卡羅演算法](#)
- [15.2 動態模型模擬](#)
- [15.3 隨機數產生器](#)
- [15.4 序列式實作 (單執行緒)](#)
- [15.5 並行化實作](#)

#### 16 敏感度分析

- [16.1 自動微分](#)
- [16.2 演算圖](#)
- [16.3 伴隨矩陣](#)
- [16.4 磁帶的使用 (Tape)](#)